<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f1383103523fa822e1fec7ef81904d5",
  "translation_date": "2025-08-11T11:24:32+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "fa"
}
-->
# پخش HTTPS با پروتکل Model Context (MCP)

این فصل راهنمای جامعی برای پیاده‌سازی پخش امن، مقیاس‌پذیر و بلادرنگ با استفاده از پروتکل Model Context (MCP) از طریق HTTPS ارائه می‌دهد. موضوعاتی مانند انگیزه برای پخش، مکانیزم‌های انتقال موجود، نحوه پیاده‌سازی HTTP قابل پخش در MCP، بهترین شیوه‌های امنیتی، مهاجرت از SSE و راهنمای عملی برای ساخت برنامه‌های MCP پخش خودتان را پوشش می‌دهد.

## مکانیزم‌های انتقال و پخش در MCP

این بخش مکانیزم‌های انتقال مختلف موجود در MCP و نقش آن‌ها در فعال‌سازی قابلیت‌های پخش برای ارتباط بلادرنگ بین کلاینت‌ها و سرورها را بررسی می‌کند.

### مکانیزم انتقال چیست؟

مکانیزم انتقال تعیین می‌کند که داده‌ها چگونه بین کلاینت و سرور تبادل می‌شوند. MCP از انواع مختلف انتقال برای تطبیق با محیط‌ها و نیازهای مختلف پشتیبانی می‌کند:

- **stdio**: ورودی/خروجی استاندارد، مناسب برای ابزارهای محلی و مبتنی بر CLI. ساده اما برای وب یا فضای ابری مناسب نیست.
- **SSE (رویدادهای ارسال‌شده از سرور)**: به سرورها اجازه می‌دهد تا به‌روزرسانی‌های بلادرنگ را از طریق HTTP به کلاینت‌ها ارسال کنند. برای رابط‌های کاربری وب خوب است، اما در مقیاس‌پذیری و انعطاف‌پذیری محدود است.
- **HTTP قابل پخش**: انتقال مدرن مبتنی بر HTTP که از اعلان‌ها و مقیاس‌پذیری بهتر پشتیبانی می‌کند. برای اکثر سناریوهای تولید و فضای ابری توصیه می‌شود.

### جدول مقایسه

جدول مقایسه زیر را ببینید تا تفاوت‌های بین این مکانیزم‌های انتقال را درک کنید:

| انتقال            | به‌روزرسانی بلادرنگ | پخش       | مقیاس‌پذیری | مورد استفاده              |
|-------------------|------------------|-----------|-------------|-------------------------|
| stdio             | خیر              | خیر        | کم          | ابزارهای CLI محلی         |
| SSE               | بله              | بله        | متوسط       | وب، به‌روزرسانی بلادرنگ  |
| HTTP قابل پخش     | بله              | بله        | بالا         | فضای ابری، چند کلاینت     |

> **نکته:** انتخاب انتقال مناسب بر عملکرد، مقیاس‌پذیری و تجربه کاربری تأثیر می‌گذارد. **HTTP قابل پخش** برای برنامه‌های مدرن، مقیاس‌پذیر و آماده برای فضای ابری توصیه می‌شود.

به انتقال‌های stdio و SSE که در فصل‌های قبلی نشان داده شد توجه کنید و اینکه چگونه HTTP قابل پخش انتقالی است که در این فصل پوشش داده می‌شود.

## پخش: مفاهیم و انگیزه

درک مفاهیم اساسی و انگیزه‌های پشت پخش برای پیاده‌سازی سیستم‌های ارتباط بلادرنگ مؤثر ضروری است.

**پخش** تکنیکی در برنامه‌نویسی شبکه است که به داده‌ها اجازه می‌دهد به‌صورت تکه‌های کوچک و قابل مدیریت یا به‌عنوان دنباله‌ای از رویدادها ارسال و دریافت شوند، به‌جای اینکه منتظر آماده شدن کل پاسخ بمانند. این تکنیک به‌ویژه برای موارد زیر مفید است:

- فایل‌ها یا مجموعه داده‌های بزرگ.
- به‌روزرسانی‌های بلادرنگ (مانند چت، نوارهای پیشرفت).
- محاسبات طولانی‌مدت که در آن می‌خواهید کاربر را مطلع نگه دارید.

آنچه باید درباره پخش در سطح بالا بدانید:

- داده‌ها به‌صورت تدریجی ارسال می‌شوند، نه به‌صورت یکجا.
- کلاینت می‌تواند داده‌ها را به محض رسیدن پردازش کند.
- تأخیر ادراک‌شده را کاهش می‌دهد و تجربه کاربری را بهبود می‌بخشد.

### چرا از پخش استفاده کنیم؟

دلایل استفاده از پخش عبارتند از:

- کاربران فوراً بازخورد دریافت می‌کنند، نه فقط در پایان.
- امکان برنامه‌های بلادرنگ و رابط‌های کاربری پاسخگو را فراهم می‌کند.
- استفاده کارآمدتر از منابع شبکه و محاسباتی.

### مثال ساده: سرور و کلاینت پخش HTTP

در اینجا یک مثال ساده از نحوه پیاده‌سازی پخش آورده شده است:

#### پایتون

**سرور (پایتون، با استفاده از FastAPI و StreamingResponse):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**کلاینت (پایتون، با استفاده از requests):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

این مثال نشان می‌دهد که چگونه یک سرور مجموعه‌ای از پیام‌ها را به کلاینت ارسال می‌کند به محض اینکه آماده شوند، به‌جای اینکه منتظر آماده شدن همه پیام‌ها بماند.

**نحوه کار:**

- سرور هر پیام را به محض آماده شدن ارسال می‌کند.
- کلاینت هر تکه را به محض رسیدن دریافت و چاپ می‌کند.

**نیازمندی‌ها:**

- سرور باید از یک پاسخ پخش‌شده استفاده کند (مانند `StreamingResponse` در FastAPI).
- کلاینت باید پاسخ را به‌صورت جریان پردازش کند (`stream=True` در requests).
- نوع محتوا معمولاً `text/event-stream` یا `application/octet-stream` است.

#### جاوا

**سرور (جاوا، با استفاده از Spring Boot و Server-Sent Events):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**کلاینت (جاوا، با استفاده از Spring WebFlux WebClient):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**نکات پیاده‌سازی در جاوا:**

- از استک واکنشی Spring Boot با `Flux` برای پخش استفاده می‌کند.
- `ServerSentEvent` پخش رویدادهای ساختاریافته با انواع رویداد را فراهم می‌کند.
- `WebClient` با `bodyToFlux()` مصرف پخش واکنشی را فعال می‌کند.
- `delayElements()` زمان پردازش بین رویدادها را شبیه‌سازی می‌کند.
- رویدادها می‌توانند انواعی مانند (`info`, `result`) داشته باشند تا کلاینت بهتر آن‌ها را مدیریت کند.

### مقایسه: پخش کلاسیک در مقابل پخش MCP

تفاوت‌های نحوه عملکرد پخش به‌صورت "کلاسیک" در مقایسه با نحوه عملکرد آن در MCP به این صورت است:

| ویژگی                 | پخش HTTP کلاسیک              | پخش MCP (اعلان‌ها)              |
|------------------------|-------------------------------|----------------------------------|
| پاسخ اصلی             | تکه‌تکه                      | یکجا، در پایان                  |
| به‌روزرسانی پیشرفت    | به‌صورت تکه‌های داده ارسال می‌شود | به‌صورت اعلان‌ها ارسال می‌شود   |
| نیازمندی‌های کلاینت   | باید جریان را پردازش کند      | باید یک مدیریت‌کننده پیام پیاده‌سازی کند |
| مورد استفاده           | فایل‌های بزرگ، جریان توکن AI | پیشرفت، لاگ‌ها، بازخورد بلادرنگ |

### تفاوت‌های کلیدی مشاهده‌شده

علاوه بر این، تفاوت‌های کلیدی زیر وجود دارد:

- **الگوی ارتباط:**
  - پخش HTTP کلاسیک: از کدگذاری انتقال تکه‌تکه ساده برای ارسال داده‌ها در تکه‌ها استفاده می‌کند.
  - پخش MCP: از یک سیستم اعلان ساختاریافته با پروتکل JSON-RPC استفاده می‌کند.

- **فرمت پیام:**
  - HTTP کلاسیک: تکه‌های متن ساده با خطوط جدید.
  - MCP: اشیاء LoggingMessageNotification ساختاریافته با متادیتا.

- **پیاده‌سازی کلاینت:**
  - HTTP کلاسیک: کلاینت ساده‌ای که پاسخ‌های پخش‌شده را پردازش می‌کند.
  - MCP: کلاینت پیچیده‌تری با یک مدیریت‌کننده پیام برای پردازش انواع مختلف پیام‌ها.

- **به‌روزرسانی‌های پیشرفت:**
  - HTTP کلاسیک: پیشرفت بخشی از جریان پاسخ اصلی است.
  - MCP: پیشرفت از طریق پیام‌های اعلان جداگانه ارسال می‌شود در حالی که پاسخ اصلی در پایان می‌آید.

### توصیه‌ها

چند توصیه برای انتخاب بین پیاده‌سازی پخش کلاسیک (به‌عنوان یک نقطه پایانی که در بالا با استفاده از `/stream` نشان دادیم) در مقابل انتخاب پخش از طریق MCP وجود دارد:

- **برای نیازهای ساده پخش:** پخش HTTP کلاسیک ساده‌تر است و برای نیازهای پخش پایه کافی است.
- **برای برنامه‌های پیچیده و تعاملی:** پخش MCP رویکرد ساختاریافته‌تری با متادیتای غنی‌تر و جداسازی بین اعلان‌ها و نتایج نهایی ارائه می‌دهد.
- **برای برنامه‌های AI:** سیستم اعلان MCP به‌ویژه برای وظایف طولانی‌مدت AI که می‌خواهید کاربران را از پیشرفت مطلع کنید مفید است.

## پخش در MCP

خب، تاکنون برخی توصیه‌ها و مقایسه‌ها را درباره تفاوت بین پخش کلاسیک و پخش در MCP مشاهده کرده‌اید. حالا دقیقاً بررسی می‌کنیم که چگونه می‌توانید از پخش در MCP استفاده کنید.

درک نحوه عملکرد پخش در چارچوب MCP برای ساخت برنامه‌های پاسخگو که بازخورد بلادرنگ به کاربران در طول عملیات طولانی‌مدت ارائه می‌دهند ضروری است.

در MCP، پخش به معنای ارسال پاسخ اصلی به‌صورت تکه‌تکه نیست، بلکه ارسال **اعلان‌ها** به کلاینت در حین پردازش درخواست توسط ابزار است. این اعلان‌ها می‌توانند شامل به‌روزرسانی‌های پیشرفت، لاگ‌ها یا رویدادهای دیگر باشند.

### نحوه کار

نتیجه اصلی همچنان به‌صورت یک پاسخ واحد ارسال می‌شود. با این حال، اعلان‌ها می‌توانند به‌عنوان پیام‌های جداگانه در طول پردازش ارسال شوند و به این ترتیب کلاینت را به‌صورت بلادرنگ به‌روزرسانی کنند. کلاینت باید بتواند این اعلان‌ها را مدیریت و نمایش دهد.

## اعلان چیست؟

گفتیم "اعلان"، این در زمینه MCP به چه معناست؟

اعلان پیامی است که از سرور به کلاینت ارسال می‌شود تا درباره پیشرفت، وضعیت یا رویدادهای دیگر در طول یک عملیات طولانی‌مدت اطلاع‌رسانی کند. اعلان‌ها شفافیت و تجربه کاربری را بهبود می‌بخشند.

برای مثال، کلاینت باید پس از انجام دست‌دهی اولیه با سرور، یک اعلان ارسال کند.

یک اعلان به‌صورت یک پیام JSON به این شکل است:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

اعلان‌ها به موضوعی در MCP به نام ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) تعلق دارند.

برای فعال کردن لاگ‌گیری، سرور باید آن را به‌عنوان یک ویژگی/قابلیت به این شکل فعال کند:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> بسته به SDK مورد استفاده، ممکن است لاگ‌گیری به‌طور پیش‌فرض فعال باشد یا نیاز باشد که به‌طور صریح در پیکربندی سرور فعال شود.

انواع مختلفی از اعلان‌ها وجود دارد:

| سطح       | توضیحات                     | مثال مورد استفاده               |
|-----------|-----------------------------|---------------------------------|
| debug     | اطلاعات اشکال‌زدایی دقیق    | نقاط ورود/خروج تابع            |
| info      | پیام‌های اطلاعاتی عمومی     | به‌روزرسانی‌های پیشرفت عملیات  |
| notice    | رویدادهای عادی اما مهم      | تغییرات پیکربندی               |
| warning   | شرایط هشدار                 | استفاده از ویژگی منسوخ         |
| error     | شرایط خطا                   | شکست عملیات                    |
| critical  | شرایط بحرانی                | شکست اجزای سیستم               |
| alert     | باید فوراً اقدام شود         | شناسایی خرابی داده             |
| emergency | سیستم غیرقابل استفاده است   | شکست کامل سیستم                |

## پیاده‌سازی اعلان‌ها در MCP

برای پیاده‌سازی اعلان‌ها در MCP، باید هم سمت سرور و هم سمت کلاینت را برای مدیریت به‌روزرسانی‌های بلادرنگ تنظیم کنید. این کار به برنامه شما اجازه می‌دهد تا بازخورد فوری به کاربران در طول عملیات طولانی‌مدت ارائه دهد.

### سمت سرور: ارسال اعلان‌ها

بیایید با سمت سرور شروع کنیم. در MCP، ابزارهایی تعریف می‌کنید که می‌توانند در حین پردازش درخواست‌ها اعلان ارسال کنند. سرور از شیء context (معمولاً `ctx`) برای ارسال پیام‌ها به کلاینت استفاده می‌کند.

#### پایتون

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

در مثال بالا، ابزار `process_files` سه اعلان به کلاینت ارسال می‌کند در حالی که هر فایل را پردازش می‌کند. متد `ctx.info()` برای ارسال پیام‌های اطلاعاتی استفاده می‌شود.

علاوه بر این، برای فعال کردن اعلان‌ها، اطمینان حاصل کنید که سرور شما از یک انتقال پخش‌شده (مانند `streamable-http`) استفاده می‌کند و کلاینت شما یک مدیریت‌کننده پیام برای پردازش اعلان‌ها پیاده‌سازی کرده است. در اینجا نحوه تنظیم سرور برای استفاده از انتقال `streamable-http` آورده شده است:

```python
mcp.run(transport="streamable-http")
```

#### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

در این مثال .NET، ابزار `ProcessFiles` با ویژگی `Tool` تزئین شده و سه اعلان به کلاینت ارسال می‌کند در حالی که هر فایل را پردازش می‌کند. متد `ctx.Info()` برای ارسال پیام‌های اطلاعاتی استفاده می‌شود.

برای فعال کردن اعلان‌ها در سرور MCP .NET خود، اطمینان حاصل کنید که از یک انتقال پخش‌شده استفاده می‌کنید:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### سمت کلاینت: دریافت اعلان‌ها

کلاینت باید یک مدیریت‌کننده پیام پیاده‌سازی کند تا اعلان‌ها را به محض رسیدن پردازش و نمایش دهد.

#### پایتون

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

در کد بالا، تابع `message_handler` بررسی می‌کند که آیا پیام ورودی یک اعلان است. اگر چنین باشد، اعلان را چاپ می‌کند؛ در غیر این صورت، آن را به‌عنوان یک پیام سرور عادی پردازش می‌کند. همچنین توجه کنید که چگونه `ClientSession` با `message_handler` برای مدیریت اعلان‌های ورودی مقداردهی اولیه می‌شود.

#### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

در این مثال .NET، تابع `MessageHandler` بررسی می‌کند که آیا پیام ورودی یک اعلان است. اگر چنین باشد، اعلان را چاپ می‌کند؛ در غیر این صورت، آن را به‌عنوان یک پیام سرور عادی پردازش می‌کند. `ClientSession` با مدیریت‌کننده پیام از طریق `ClientSessionOptions` مقداردهی اولیه می‌شود.

برای فعال کردن اعلان‌ها، اطمینان حاصل کنید که سرور شما از یک انتقال پخش‌شده (مانند `streamable-http`) استفاده می‌کند و کلاینت شما یک مدیریت‌کننده پیام برای پردازش اعلان‌ها پیاده‌سازی کرده است.

## اعلان‌های پیشرفت و سناریوها

این بخش مفهوم اعلان‌های پیشرفت در MCP، اهمیت آن‌ها و نحوه پیاده‌سازی آن‌ها با استفاده از HTTP قابل پخش را توضیح می‌دهد. همچنین یک تمرین عملی برای تقویت درک شما ارائه می‌دهد.

اعلان‌های پیشرفت پیام‌های بلادرنگی هستند که از سرور به کلاینت در طول عملیات طولانی‌مدت ارسال می‌شوند. به‌جای انتظار برای اتمام کل فرآیند، سرور کلاینت را از وضعیت فعلی مطلع می‌کند. این کار شفافیت، تجربه کاربری و اشکال‌زدایی را بهبود می‌بخشد.

**مثال:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### چرا از اعلان‌های پیشرفت استفاده کنیم؟

اعلان‌های پیشرفت به دلایل زیر ضروری هستند:

- **تجربه کاربری بهتر:** کاربران به‌روزرسانی‌ها را در حین پیشرفت کار مشاهده می‌کنند، نه فقط در پایان.
- **بازخورد بلادرنگ:** کلاینت‌ها می‌توانند نوارهای پیشرفت یا لاگ‌ها را نمایش دهند و برنامه را پاسخگوتر کنند.
- **اشکال‌زدایی و نظارت آسان‌تر:** توسعه‌دهندگان و کاربران می‌توانند ببینند که یک فرآیند ممکن است کجا کند یا متوقف شده باشد.

### نحوه پیاده‌سازی اعلان‌های پیشرفت

در اینجا نحوه پیاده‌سازی اعلان‌های پیشرفت در MCP آورده شده است:

- **در سرور:** از `ctx.info()` یا `ctx.log()` برای ارسال اعلان‌ها به‌محض پردازش هر آیتم استفاده کنید. این کار قبل از آماده شدن نتیجه اصلی یک پیام به کلاینت ارسال می‌کند.
- **در کلاینت:** یک مدیریت‌کننده پیام پیاده‌سازی کنید که اعلان‌ها را به‌محض رسیدن گوش دهد و نمایش دهد. این مدیریت‌کننده بین اعلان‌ها و نتیجه نهایی تمایز قائل می‌شود.

**مثال سرور:**

#### پایتون

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

**مثال کلاینت:**

#### پایتون

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

## ملاحظات امنیتی

هنگام پیاده‌سازی سرورهای MCP با انتقال‌های مبتنی بر HTTP، امنیت به یک نگرانی اساسی تبدیل می‌شود که نیاز به توجه دقیق به بردارهای حمله و مکانیزم‌های حفاظتی دارد.

### مرور کلی

امنیت هنگام افشای سرورهای MCP از طریق HTTP حیاتی است. HTTP قابل پخش سطوح حمله جدیدی را معرفی می‌کند و نیاز به پیکربندی دقیق دارد.

### نکات کلیدی

- **اعتبارسنجی هدر Origin:** همیشه هدر `Origin` را برای جلوگیری از حملات بازبایندینگ DNS اعتبارسنجی کنید.
- **اتصال به Localhost:** برای توسعه محلی، سرورها را به `localhost` متصل کنید تا از افشای آن‌ها در اینترنت عمومی جلوگیری شود.
- **احراز هویت:** احراز هویت (مانند کلیدهای API، OAuth) را برای استقرارهای تولیدی پیاده‌سازی کنید.
- **CORS:** سیاست‌های Cross-Origin Resource Sharing (CORS) را برای محدود کردن دسترسی پیکربندی کنید.
- **HTTPS:** در تولید از HTTPS برای رمزگذاری ترافیک استفاده کنید.

### بهترین شیوه‌ها

- هرگز به درخواست‌های ورودی بدون اعتبارسنجی اعتماد نکنید.
- همه دسترسی‌ها و خطا
دو دلیل قانع‌کننده برای ارتقا از SSE به Streamable HTTP وجود دارد:

- Streamable HTTP مقیاس‌پذیری بهتر، سازگاری بیشتر و پشتیبانی غنی‌تری از اعلان‌ها نسبت به SSE ارائه می‌دهد.
- این روش به‌عنوان انتقال پیشنهادی برای برنامه‌های جدید MCP توصیه می‌شود.

### مراحل مهاجرت

در اینجا نحوه مهاجرت از SSE به Streamable HTTP در برنامه‌های MCP آورده شده است:

- **کد سرور را به‌روزرسانی کنید** تا از `transport="streamable-http"` در `mcp.run()` استفاده کند.
- **کد کلاینت را به‌روزرسانی کنید** تا به جای کلاینت SSE از `streamablehttp_client` استفاده کند.
- **یک هندلر پیام پیاده‌سازی کنید** تا اعلان‌ها را در کلاینت پردازش کند.
- **سازگاری را آزمایش کنید** تا مطمئن شوید ابزارها و جریان‌های کاری موجود همچنان کار می‌کنند.

### حفظ سازگاری

توصیه می‌شود در طول فرآیند مهاجرت، سازگاری با کلاینت‌های SSE موجود حفظ شود. در اینجا چند استراتژی آورده شده است:

- می‌توانید با اجرای هر دو انتقال در نقاط پایانی مختلف، از هر دو SSE و Streamable HTTP پشتیبانی کنید.
- کلاینت‌ها را به‌تدریج به انتقال جدید مهاجرت دهید.

### چالش‌ها

اطمینان حاصل کنید که چالش‌های زیر را در طول مهاجرت برطرف می‌کنید:

- اطمینان از به‌روزرسانی تمام کلاینت‌ها
- مدیریت تفاوت‌ها در تحویل اعلان‌ها

## ملاحظات امنیتی

امنیت باید اولویت اصلی هنگام پیاده‌سازی هر سروری باشد، به‌ویژه زمانی که از انتقال‌های مبتنی بر HTTP مانند Streamable HTTP در MCP استفاده می‌کنید.

هنگام پیاده‌سازی سرورهای MCP با انتقال‌های مبتنی بر HTTP، امنیت به یک نگرانی اساسی تبدیل می‌شود که نیازمند توجه دقیق به بردارهای حمله و مکانیزم‌های حفاظتی است.

### مرور کلی

امنیت هنگام ارائه سرورهای MCP از طریق HTTP بسیار حیاتی است. Streamable HTTP سطوح حمله جدیدی را معرفی می‌کند و نیازمند پیکربندی دقیق است.

در اینجا برخی از ملاحظات کلیدی امنیتی آورده شده است:

- **اعتبارسنجی هدر Origin**: همیشه هدر `Origin` را اعتبارسنجی کنید تا از حملات DNS rebinding جلوگیری شود.
- **اتصال به Localhost**: برای توسعه محلی، سرورها را به `localhost` متصل کنید تا از دسترسی به اینترنت عمومی جلوگیری شود.
- **احراز هویت**: برای استقرارهای تولیدی، احراز هویت (مانند کلیدهای API، OAuth) را پیاده‌سازی کنید.
- **CORS**: سیاست‌های Cross-Origin Resource Sharing (CORS) را برای محدود کردن دسترسی پیکربندی کنید.
- **HTTPS**: در محیط تولید از HTTPS استفاده کنید تا ترافیک رمزگذاری شود.

### بهترین شیوه‌ها

علاوه بر این، در اینجا برخی از بهترین شیوه‌ها برای پیاده‌سازی امنیت در سرور استریمینگ MCP آورده شده است:

- هرگز به درخواست‌های ورودی بدون اعتبارسنجی اعتماد نکنید.
- تمام دسترسی‌ها و خطاها را ثبت و نظارت کنید.
- وابستگی‌ها را به‌طور منظم به‌روزرسانی کنید تا آسیب‌پذیری‌های امنیتی برطرف شوند.

### چالش‌ها

در هنگام پیاده‌سازی امنیت در سرورهای استریمینگ MCP با چالش‌هایی مواجه خواهید شد:

- ایجاد تعادل بین امنیت و سهولت توسعه
- اطمینان از سازگاری با محیط‌های مختلف کلاینت

### تمرین: ساخت برنامه استریمینگ MCP خود

**سناریو:**
یک سرور و کلاینت MCP بسازید که در آن سرور یک لیست از آیتم‌ها (مانند فایل‌ها یا اسناد) را پردازش کرده و برای هر آیتم پردازش‌شده یک اعلان ارسال کند. کلاینت باید هر اعلان را به‌محض دریافت نمایش دهد.

**مراحل:**

1. یک ابزار سرور پیاده‌سازی کنید که یک لیست را پردازش کرده و برای هر آیتم اعلان ارسال کند.
2. یک کلاینت با یک هندلر پیام پیاده‌سازی کنید تا اعلان‌ها را به‌صورت بلادرنگ نمایش دهد.
3. پیاده‌سازی خود را با اجرای سرور و کلاینت آزمایش کنید و اعلان‌ها را مشاهده کنید.

[راه‌حل](./solution/README.md)

## مطالعه بیشتر و گام‌های بعدی

برای ادامه مسیر خود با استریمینگ MCP و گسترش دانش خود، این بخش منابع اضافی و گام‌های پیشنهادی برای ساخت برنامه‌های پیشرفته‌تر را ارائه می‌دهد.

### مطالعه بیشتر

- [Microsoft: مقدمه‌ای بر استریمینگ HTTP](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: رویدادهای ارسال‌شده از سرور (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS در ASP.NET Core](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: درخواست‌های استریمینگ](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### گام‌های بعدی

- تلاش کنید ابزارهای پیشرفته‌تر MCP بسازید که از استریمینگ برای تحلیل بلادرنگ، چت یا ویرایش مشارکتی استفاده می‌کنند.
- ادغام استریمینگ MCP با فریم‌ورک‌های فرانت‌اند (React، Vue و غیره) را برای به‌روزرسانی زنده رابط کاربری بررسی کنید.
- گام بعدی: [استفاده از ابزار AI برای VSCode](../07-aitk/README.md)

**سلب مسئولیت**:  
این سند با استفاده از سرویس ترجمه هوش مصنوعی [Co-op Translator](https://github.com/Azure/co-op-translator) ترجمه شده است. در حالی که ما تلاش می‌کنیم دقت را حفظ کنیم، لطفاً توجه داشته باشید که ترجمه‌های خودکار ممکن است شامل خطاها یا نادرستی‌ها باشند. سند اصلی به زبان اصلی آن باید به عنوان منبع معتبر در نظر گرفته شود. برای اطلاعات حساس، توصیه می‌شود از ترجمه حرفه‌ای انسانی استفاده کنید. ما مسئولیتی در قبال سوء تفاهم‌ها یا تفسیرهای نادرست ناشی از استفاده از این ترجمه نداریم.