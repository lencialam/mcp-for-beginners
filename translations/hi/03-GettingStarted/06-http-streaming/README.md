<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f1383103523fa822e1fec7ef81904d5",
  "translation_date": "2025-08-11T11:55:18+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "hi"
}
-->
# HTTPS स्ट्रीमिंग और मॉडल कॉन्टेक्स्ट प्रोटोकॉल (MCP)

यह अध्याय HTTPS का उपयोग करके सुरक्षित, स्केलेबल और रियल-टाइम स्ट्रीमिंग को लागू करने के लिए मॉडल कॉन्टेक्स्ट प्रोटोकॉल (MCP) का एक व्यापक मार्गदर्शन प्रदान करता है। इसमें स्ट्रीमिंग की आवश्यकता, उपलब्ध ट्रांसपोर्ट मैकेनिज़्म, MCP में स्ट्रीमेबल HTTP को लागू करने का तरीका, सुरक्षा सर्वोत्तम प्रथाएँ, SSE से माइग्रेशन, और अपने स्वयं के स्ट्रीमिंग MCP एप्लिकेशन बनाने के लिए व्यावहारिक मार्गदर्शन शामिल है।

## MCP में ट्रांसपोर्ट मैकेनिज़्म और स्ट्रीमिंग

यह अनुभाग MCP में उपलब्ध विभिन्न ट्रांसपोर्ट मैकेनिज़्म और क्लाइंट और सर्वर के बीच रियल-टाइम संचार को सक्षम करने में उनकी भूमिका की जांच करता है।

### ट्रांसपोर्ट मैकेनिज़्म क्या है?

ट्रांसपोर्ट मैकेनिज़्म यह परिभाषित करता है कि क्लाइंट और सर्वर के बीच डेटा का आदान-प्रदान कैसे होता है। MCP विभिन्न परिवेशों और आवश्यकताओं के अनुरूप कई ट्रांसपोर्ट प्रकारों का समर्थन करता है:

- **stdio**: स्टैंडर्ड इनपुट/आउटपुट, स्थानीय और CLI-आधारित टूल्स के लिए उपयुक्त। सरल लेकिन वेब या क्लाउड के लिए उपयुक्त नहीं।
- **SSE (सर्वर-सेंट इवेंट्स)**: सर्वर को HTTP पर क्लाइंट्स को रियल-टाइम अपडेट पुश करने की अनुमति देता है। वेब UI के लिए अच्छा है, लेकिन स्केलेबिलिटी और लचीलापन में सीमित।
- **स्ट्रीमेबल HTTP**: आधुनिक HTTP-आधारित स्ट्रीमिंग ट्रांसपोर्ट, जो नोटिफिकेशन और बेहतर स्केलेबिलिटी का समर्थन करता है। अधिकांश प्रोडक्शन और क्लाउड परिदृश्यों के लिए अनुशंसित।

### तुलना तालिका

नीचे दी गई तुलना तालिका पर एक नज़र डालें ताकि इन ट्रांसपोर्ट मैकेनिज़्म के बीच अंतर को समझा जा सके:

| ट्रांसपोर्ट         | रियल-टाइम अपडेट | स्ट्रीमिंग | स्केलेबिलिटी | उपयोग का मामला                |
|-------------------|------------------|-----------|-------------|-------------------------|
| stdio             | नहीं               | नहीं        | कम         | स्थानीय CLI टूल्स         |
| SSE               | हाँ              | हाँ       | मध्यम      | वेब, रियल-टाइम अपडेट  |
| स्ट्रीमेबल HTTP   | हाँ              | हाँ       | उच्च        | क्लाउड, मल्टी-क्लाइंट     |

> **टिप:** सही ट्रांसपोर्ट का चयन प्रदर्शन, स्केलेबिलिटी और उपयोगकर्ता अनुभव को प्रभावित करता है। **स्ट्रीमेबल HTTP** आधुनिक, स्केलेबल और क्लाउड-रेडी एप्लिकेशन के लिए अनुशंसित है।

पिछले अध्यायों में आपको stdio और SSE ट्रांसपोर्ट दिखाए गए थे और इस अध्याय में स्ट्रीमेबल HTTP ट्रांसपोर्ट को कवर किया गया है।

## स्ट्रीमिंग: अवधारणाएँ और प्रेरणा

रियल-टाइम संचार प्रणालियों को प्रभावी ढंग से लागू करने के लिए स्ट्रीमिंग की मूलभूत अवधारणाओं और प्रेरणाओं को समझना आवश्यक है।

**स्ट्रीमिंग** नेटवर्क प्रोग्रामिंग में एक तकनीक है जो डेटा को छोटे, प्रबंधनीय टुकड़ों या घटनाओं की श्रृंखला के रूप में भेजने और प्राप्त करने की अनुमति देती है, बजाय इसके कि पूरे उत्तर के तैयार होने की प्रतीक्षा की जाए। यह विशेष रूप से उपयोगी है:

- बड़े फाइलों या डेटा सेट के लिए।
- रियल-टाइम अपडेट (जैसे, चैट, प्रोग्रेस बार)।
- लंबे समय तक चलने वाले गणनाओं के लिए जहां आप उपयोगकर्ता को सूचित रखना चाहते हैं।

स्ट्रीमिंग के बारे में उच्च स्तर पर जानने योग्य बातें:

- डेटा प्रगतिशील रूप से वितरित किया जाता है, एक बार में नहीं।
- क्लाइंट डेटा को उसके आने पर ही प्रोसेस कर सकता है।
- प्रतीत होने वाली विलंबता को कम करता है और उपयोगकर्ता अनुभव को बेहतर बनाता है।

### स्ट्रीमिंग का उपयोग क्यों करें?

स्ट्रीमिंग का उपयोग करने के कारण निम्नलिखित हैं:

- उपयोगकर्ताओं को तुरंत प्रतिक्रिया मिलती है, केवल अंत में नहीं।
- रियल-टाइम एप्लिकेशन और उत्तरदायी UI को सक्षम करता है।
- नेटवर्क और कंप्यूट संसाधनों का अधिक कुशल उपयोग।

### सरल उदाहरण: HTTP स्ट्रीमिंग सर्वर और क्लाइंट

स्ट्रीमिंग को कैसे लागू किया जा सकता है इसका एक सरल उदाहरण यहां दिया गया है:

#### Python

**सर्वर (Python, FastAPI और StreamingResponse का उपयोग करके):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**क्लाइंट (Python, requests का उपयोग करके):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

यह उदाहरण दिखाता है कि सर्वर संदेशों की एक श्रृंखला को क्लाइंट को भेजता है जैसे ही वे उपलब्ध होते हैं, बजाय इसके कि सभी संदेशों के तैयार होने की प्रतीक्षा की जाए।

**यह कैसे काम करता है:**

- सर्वर प्रत्येक संदेश को तैयार होने पर भेजता है।
- क्लाइंट प्रत्येक चंक को उसके आने पर प्राप्त करता है और प्रिंट करता है।

**आवश्यकताएँ:**

- सर्वर को स्ट्रीमिंग प्रतिक्रिया का उपयोग करना चाहिए (जैसे, FastAPI में `StreamingResponse`)।
- क्लाइंट को प्रतिक्रिया को स्ट्रीम के रूप में प्रोसेस करना चाहिए (`stream=True` requests में)।
- Content-Type आमतौर पर `text/event-stream` या `application/octet-stream` होता है।

#### Java

**सर्वर (Java, Spring Boot और Server-Sent Events का उपयोग करके):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**क्लाइंट (Java, Spring WebFlux WebClient का उपयोग करके):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java कार्यान्वयन नोट्स:**

- Spring Boot के रिएक्टिव स्टैक का उपयोग `Flux` के साथ स्ट्रीमिंग के लिए करता है।
- `ServerSentEvent` इवेंट प्रकारों के साथ संरचित इवेंट स्ट्रीमिंग प्रदान करता है।
- `WebClient` के साथ `bodyToFlux()` रिएक्टिव स्ट्रीमिंग खपत को सक्षम करता है।
- `delayElements()` इवेंट्स के बीच प्रोसेसिंग समय का अनुकरण करता है।
- इवेंट्स में बेहतर क्लाइंट हैंडलिंग के लिए प्रकार (`info`, `result`) हो सकते हैं।

### तुलना: क्लासिक स्ट्रीमिंग बनाम MCP स्ट्रीमिंग

क्लासिक तरीके से स्ट्रीमिंग और MCP में स्ट्रीमिंग कैसे काम करती है, इसके बीच के अंतर को इस प्रकार दिखाया जा सकता है:

| विशेषता                | क्लासिक HTTP स्ट्रीमिंग         | MCP स्ट्रीमिंग (नोटिफिकेशन)      |
|------------------------|-------------------------------|-------------------------------------|
| मुख्य प्रतिक्रिया          | चंक्ड                       | अंत में एकल                          |
| प्रगति अपडेट           | डेटा चंक्स के रूप में भेजा गया | नोटिफिकेशन के रूप में भेजा गया       |
| क्लाइंट आवश्यकताएँ    | स्ट्रीम को प्रोसेस करना चाहिए   | संदेश हैंडलर को लागू करना चाहिए      |
| उपयोग का मामला               | बड़ी फाइलें, AI टोकन स्ट्रीम्स | प्रगति, लॉग्स, रियल-टाइम फीडबैक  |

### देखे गए प्रमुख अंतर

इसके अतिरिक्त, कुछ प्रमुख अंतर हैं:

- **संचार पैटर्न:**
  - क्लासिक HTTP स्ट्रीमिंग: डेटा को चंक्स में भेजने के लिए सरल चंक्ड ट्रांसफर एनकोडिंग का उपयोग करता है।
  - MCP स्ट्रीमिंग: JSON-RPC प्रोटोकॉल के साथ संरचित नोटिफिकेशन सिस्टम का उपयोग करता है।

- **संदेश प्रारूप:**
  - क्लासिक HTTP: न्यूलाइन के साथ सादा टेक्स्ट चंक्स।
  - MCP: मेटाडेटा के साथ संरचित LoggingMessageNotification ऑब्जेक्ट्स।

- **क्लाइंट कार्यान्वयन:**
  - क्लासिक HTTP: स्ट्रीमिंग प्रतिक्रियाओं को प्रोसेस करने वाला सरल क्लाइंट।
  - MCP: विभिन्न प्रकार के संदेशों को प्रोसेस करने के लिए संदेश हैंडलर के साथ अधिक परिष्कृत क्लाइंट।

- **प्रगति अपडेट:**
  - क्लासिक HTTP: प्रगति मुख्य प्रतिक्रिया स्ट्रीम का हिस्सा है।
  - MCP: प्रगति अलग नोटिफिकेशन संदेशों के माध्यम से भेजी जाती है जबकि मुख्य प्रतिक्रिया अंत में आती है।

### अनुशंसाएँ

क्लासिक स्ट्रीमिंग (जैसा कि हमने आपको `/stream` एंडपॉइंट का उपयोग करके ऊपर दिखाया) को लागू करने और MCP के माध्यम से स्ट्रीमिंग चुनने के बीच चयन करने के लिए कुछ अनुशंसाएँ हैं:

- **सरल स्ट्रीमिंग आवश्यकताओं के लिए:** क्लासिक HTTP स्ट्रीमिंग को लागू करना सरल है और बुनियादी स्ट्रीमिंग आवश्यकताओं के लिए पर्याप्त है।

- **जटिल, इंटरैक्टिव एप्लिकेशन के लिए:** MCP स्ट्रीमिंग एक अधिक संरचित दृष्टिकोण प्रदान करता है जिसमें समृद्ध मेटाडेटा और नोटिफिकेशन और अंतिम परिणाम के बीच अलगाव होता है।

- **AI एप्लिकेशन के लिए:** MCP का नोटिफिकेशन सिस्टम लंबे समय तक चलने वाले AI कार्यों के लिए विशेष रूप से उपयोगी है जहां आप उपयोगकर्ताओं को प्रगति के बारे में सूचित रखना चाहते हैं।

## MCP में स्ट्रीमिंग

ठीक है, आपने अब तक क्लासिक स्ट्रीमिंग और MCP में स्ट्रीमिंग के बीच कुछ अनुशंसाएँ और तुलना देखी। आइए विस्तार से जानें कि MCP में स्ट्रीमिंग का लाभ कैसे उठाया जा सकता है।

MCP फ्रेमवर्क के भीतर स्ट्रीमिंग कैसे काम करती है, इसे समझना उत्तरदायी एप्लिकेशन बनाने के लिए आवश्यक है जो लंबे समय तक चलने वाले ऑपरेशनों के दौरान उपयोगकर्ताओं को रियल-टाइम फीडबैक प्रदान करते हैं।

MCP में, स्ट्रीमिंग मुख्य प्रतिक्रिया को चंक्स में भेजने के बारे में नहीं है, बल्कि **नोटिफिकेशन** को क्लाइंट को भेजने के बारे में है जब कोई टूल अनुरोध को प्रोसेस कर रहा हो। ये नोटिफिकेशन प्रगति अपडेट, लॉग्स, या अन्य इवेंट्स शामिल कर सकते हैं।

### यह कैसे काम करता है

मुख्य परिणाम अभी भी एकल प्रतिक्रिया के रूप में भेजा जाता है। हालांकि, प्रोसेसिंग के दौरान नोटिफिकेशन अलग-अलग संदेशों के रूप में भेजे जा सकते हैं और इस प्रकार क्लाइंट को रियल-टाइम में अपडेट कर सकते हैं। क्लाइंट को इन नोटिफिकेशन को संभालने और प्रदर्शित करने में सक्षम होना चाहिए।
SSE से Streamable HTTP में अपग्रेड करने के दो प्रमुख कारण हैं:

- Streamable HTTP, SSE की तुलना में बेहतर स्केलेबिलिटी, संगतता और अधिक समृद्ध नोटिफिकेशन समर्थन प्रदान करता है।  
- यह नई MCP एप्लिकेशन के लिए अनुशंसित ट्रांसपोर्ट है।  

### माइग्रेशन के चरण

यहां बताया गया है कि आप अपने MCP एप्लिकेशन में SSE से Streamable HTTP में कैसे माइग्रेट कर सकते हैं:

- **सर्वर कोड अपडेट करें** ताकि `mcp.run()` में `transport="streamable-http"` का उपयोग हो।  
- **क्लाइंट कोड अपडेट करें** ताकि SSE क्लाइंट की जगह `streamablehttp_client` का उपयोग हो।  
- **क्लाइंट में एक मैसेज हैंडलर लागू करें** ताकि नोटिफिकेशन को प्रोसेस किया जा सके।  
- **मौजूदा टूल्स और वर्कफ़्लो के साथ संगतता का परीक्षण करें।**  

### संगतता बनाए रखना

माइग्रेशन प्रक्रिया के दौरान मौजूदा SSE क्लाइंट्स के साथ संगतता बनाए रखना अनुशंसित है। यहां कुछ रणनीतियां दी गई हैं:

- आप SSE और Streamable HTTP दोनों को अलग-अलग एंडपॉइंट्स पर चलाकर समर्थन दे सकते हैं।  
- धीरे-धीरे क्लाइंट्स को नए ट्रांसपोर्ट पर माइग्रेट करें।  

### चुनौतियां

माइग्रेशन के दौरान निम्नलिखित चुनौतियों का समाधान सुनिश्चित करें:

- सभी क्लाइंट्स को अपडेट करना।  
- नोटिफिकेशन डिलीवरी में अंतर को संभालना।  

## सुरक्षा संबंधी विचार

HTTP-आधारित ट्रांसपोर्ट जैसे Streamable HTTP का उपयोग करते समय सुरक्षा सर्वोच्च प्राथमिकता होनी चाहिए।  

MCP सर्वर को HTTP-आधारित ट्रांसपोर्ट के साथ लागू करते समय, सुरक्षा एक महत्वपूर्ण चिंता बन जाती है, जिसके लिए कई हमले के वेक्टर और सुरक्षा तंत्रों पर सावधानीपूर्वक ध्यान देने की आवश्यकता होती है।  

### अवलोकन

जब MCP सर्वर को HTTP पर एक्सपोज़ किया जाता है, तो सुरक्षा महत्वपूर्ण हो जाती है। Streamable HTTP नए हमले के सतहों को पेश करता है और इसके लिए सावधानीपूर्वक कॉन्फ़िगरेशन की आवश्यकता होती है।  

यहां कुछ प्रमुख सुरक्षा विचार दिए गए हैं:

- **Origin हेडर वैलिडेशन**: DNS रीबाइंडिंग हमलों को रोकने के लिए हमेशा `Origin` हेडर को वैलिडेट करें।  
- **Localhost बाइंडिंग**: लोकल डेवलपमेंट के लिए, सर्वर को `localhost` पर बाइंड करें ताकि इसे सार्वजनिक इंटरनेट पर एक्सपोज़ न किया जाए।  
- **प्रमाणीकरण**: प्रोडक्शन डिप्लॉयमेंट के लिए प्रमाणीकरण (जैसे API कीज़, OAuth) लागू करें।  
- **CORS**: क्रॉस-ओरिजिन रिसोर्स शेयरिंग (CORS) नीतियों को कॉन्फ़िगर करें ताकि एक्सेस को प्रतिबंधित किया जा सके।  
- **HTTPS**: ट्रैफिक को एन्क्रिप्ट करने के लिए प्रोडक्शन में HTTPS का उपयोग करें।  

### सर्वोत्तम प्रथाएं

इसके अतिरिक्त, MCP स्ट्रीमिंग सर्वर में सुरक्षा लागू करते समय निम्नलिखित सर्वोत्तम प्रथाओं का पालन करें:

- बिना वैलिडेशन के आने वाले अनुरोधों पर कभी भरोसा न करें।  
- सभी एक्सेस और त्रुटियों को लॉग और मॉनिटर करें।  
- सुरक्षा कमजोरियों को पैच करने के लिए नियमित रूप से डिपेंडेंसी अपडेट करें।  

### चुनौतियां

MCP स्ट्रीमिंग सर्वर में सुरक्षा लागू करते समय आपको कुछ चुनौतियों का सामना करना पड़ेगा:

- सुरक्षा और विकास में आसानी के बीच संतुलन बनाना।  
- विभिन्न क्लाइंट वातावरणों के साथ संगतता सुनिश्चित करना।  

### असाइनमेंट: अपना खुद का स्ट्रीमिंग MCP ऐप बनाएं

**परिदृश्य:**  
एक MCP सर्वर और क्लाइंट बनाएं, जहां सर्वर आइटम्स (जैसे फाइल्स या डॉक्यूमेंट्स) की एक सूची को प्रोसेस करता है और प्रत्येक प्रोसेस किए गए आइटम के लिए एक नोटिफिकेशन भेजता है। क्लाइंट को प्रत्येक नोटिफिकेशन को रियल टाइम में प्रदर्शित करना चाहिए।  

**चरण:**  

1. एक सर्वर टूल लागू करें जो एक सूची को प्रोसेस करता है और प्रत्येक आइटम के लिए नोटिफिकेशन भेजता है।  
2. एक क्लाइंट लागू करें जिसमें नोटिफिकेशन को रियल टाइम में प्रदर्शित करने के लिए एक मैसेज हैंडलर हो।  
3. सर्वर और क्लाइंट दोनों को चलाकर अपने कार्यान्वयन का परीक्षण करें और नोटिफिकेशन का अवलोकन करें।  

[Solution](./solution/README.md)  

## आगे पढ़ें और आगे क्या करें?

MCP स्ट्रीमिंग के साथ अपनी यात्रा जारी रखने और अधिक उन्नत एप्लिकेशन बनाने के लिए अपने ज्ञान का विस्तार करने के लिए यह अनुभाग अतिरिक्त संसाधन और सुझाए गए अगले कदम प्रदान करता है।  

### आगे पढ़ें

- [Microsoft: HTTP स्ट्रीमिंग का परिचय](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)  
- [Microsoft: सर्वर-सेंट इवेंट्स (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)  
- [Microsoft: ASP.NET Core में CORS](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)  
- [Python requests: स्ट्रीमिंग अनुरोध](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)  

### आगे क्या करें?

- रियल-टाइम एनालिटिक्स, चैट, या सहयोगात्मक संपादन के लिए स्ट्रीमिंग का उपयोग करने वाले अधिक उन्नत MCP टूल बनाने का प्रयास करें।  
- लाइव UI अपडेट के लिए MCP स्ट्रीमिंग को फ्रंटएंड फ्रेमवर्क (React, Vue, आदि) के साथ एकीकृत करने का अन्वेषण करें।  
- अगला: [VSCode के लिए AI टूलकिट का उपयोग करना](../07-aitk/README.md)  

**अस्वीकरण**:  
यह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को आधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।